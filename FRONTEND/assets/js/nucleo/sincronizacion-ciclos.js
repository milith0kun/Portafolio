/**
 * Sistema de Sincronizaci√≥n de Ciclos Acad√©micos
 * Maneja la sincronizaci√≥n global del ciclo seleccionado en todas las p√°ginas
 */

const SincronizacionCiclos = {
    // Estado global del ciclo
    estado: {
        cicloSeleccionado: null,
        informacionCiclo: null,
        ultimaActualizacion: null,
        suscriptores: new Set(),
        servidorOffline: false,
        estableciendoCiclo: false
    },

    // Configuraci√≥n
    config: {
        intervaloActualizacion: 30000, // 30 segundos
        tiempoCache: 5 * 60 * 1000, // 5 minutos
        endpoints: {
            ciclos: '/ciclos',
            cicloActivo: '/ciclos/activo',
            estadisticas: '/dashboard/estadisticas'
        }
    },

    /**
     * Inicializar el sistema de sincronizaci√≥n
     */
    inicializar() {
        // Solo mostrar en modo debug para evitar spam
        if (window.CONFIG?.DEBUG) {
            console.log('üîÑ Inicializando sistema de sincronizaci√≥n de ciclos...');
        }
        
        // Cargar ciclo inicial
        this.cargarCicloInicial();
        
        // Configurar eventos globales
        this.configurarEventosGlobales();
        
        // Configurar actualizaci√≥n autom√°tica
        this.configurarActualizacionAutomatica();
        
        // Emitir evento de inicializaci√≥n
        this.emitirEvento('sincronizacion-inicializada', {
            ciclo: this.estado.cicloSeleccionado,
            timestamp: new Date()
        });
        
        console.log('‚úÖ Sistema de sincronizaci√≥n de ciclos inicializado');
    },

    /**
     * Cargar el ciclo inicial desde m√∫ltiples fuentes
     */
    async cargarCicloInicial() {
        try {
            // 1. Intentar obtener desde localStorage/sessionStorage
            let cicloId = localStorage.getItem('cicloSeleccionado') || 
                         sessionStorage.getItem('cicloSeleccionado');
            
            // 2. Si no hay ciclo guardado, intentar obtener el activo del servidor
            if (!cicloId) {
                console.log('üîÑ No hay ciclo guardado, obteniendo ciclo activo...');
                try {
                    const cicloActivo = await this.obtenerCicloActivo();
                    if (cicloActivo) {
                        cicloId = cicloActivo.id.toString();
                        console.log(`‚úÖ Ciclo activo encontrado: ${cicloActivo.nombre}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è No se pudo obtener ciclo activo del servidor:', error.message);
                }
            }
            
            // 3. Si a√∫n no hay ciclo, usar valor por defecto
            if (!cicloId) {
                cicloId = '1'; // Ciclo por defecto
                console.log('üîÑ Usando ciclo por defecto: 1');
            }
            
            // 4. Establecer el ciclo
            await this.establecerCiclo(cicloId);
            
        } catch (error) {
            console.error('‚ùå Error cargando ciclo inicial:', error);
            // Usar ciclo por defecto en caso de error
            await this.establecerCiclo('1');
        }
    },

    /**
     * Obtener ciclo activo del servidor
     */
    async obtenerCicloActivo() {
        try {
            const response = await window.apiRequest(this.config.endpoints.cicloActivo, 'GET');
            return response.data;
        } catch (error) {
            // Solo mostrar warning si no es un error de conexi√≥n
            if (!error.message?.includes('Failed to fetch')) {
                console.warn('‚ö†Ô∏è Error obteniendo ciclo activo:', error.message);
            }
            return null;
        }
    },

    /**
     * Establecer ciclo seleccionado con debounce para evitar conflictos
     */
    async establecerCiclo(cicloId) {
        // Evitar cambios duplicados o muy r√°pidos
        if (this.estado.estableciendoCiclo || cicloId === this.estado.cicloSeleccionado) {
            return;
        }
        
        // Cancelar cualquier cambio pendiente
        if (this.timeoutEstablecerCiclo) {
            clearTimeout(this.timeoutEstablecerCiclo);
        }
        
        // Marcar como en proceso
        this.estado.estableciendoCiclo = true;
        
        console.log(`üîÑ Estableciendo ciclo: ${cicloId}`);
        
        try {
            // Guardar en almacenamiento
            localStorage.setItem('cicloSeleccionado', cicloId);
            sessionStorage.setItem('cicloSeleccionado', cicloId);
            
            // Actualizar estado interno
            this.estado.cicloSeleccionado = cicloId;
            this.estado.ultimaActualizacion = new Date();
            
            // Obtener informaci√≥n completa del ciclo
            await this.obtenerInformacionCiclo(cicloId);
            
            // Actualizar selectores en todas las p√°ginas
            this.actualizarSelectoresCiclo(cicloId);
            
            // Usar debounce para emitir eventos (evitar spam)
            this.timeoutEstablecerCiclo = setTimeout(() => {
                // Emitir eventos de cambio de ciclo (ambos para compatibilidad)
                this.emitirEvento('ciclo-cambiado', {
                    cicloId: cicloId,
                    informacion: this.estado.informacionCiclo,
                    timestamp: new Date()
                });
                
                // Emitir evento nuevo para sincronizaci√≥n moderna
                this.emitirEvento('cicloActivoCambiado', {
                    cicloId: cicloId,
                    cicloActivo: this.estado.informacionCiclo,
                    timestamp: new Date()
                });
                
                // Notificar a suscriptores
                this.notificarSuscriptores();
                
                console.log(`‚úÖ Ciclo establecido: ${cicloId}`);
            }, 100); // Debounce de 100ms
            
        } finally {
            // Liberar el lock despu√©s de un breve delay
            setTimeout(() => {
                this.estado.estableciendoCiclo = false;
            }, 200);
        }
    },

    /**
     * Obtener informaci√≥n completa del ciclo
     */
    async obtenerInformacionCiclo(cicloId) {
        try {
            // Intentar obtener desde el servidor
            const response = await window.apiRequest(`${this.config.endpoints.ciclos}/${cicloId}`, 'GET');
            this.estado.informacionCiclo = response.data;
        } catch (error) {
            // Solo mostrar warning si no es un error de conexi√≥n
            if (!error.message?.includes('Failed to fetch')) {
                console.warn('‚ö†Ô∏è Error obteniendo informaci√≥n del ciclo, usando datos b√°sicos:', error.message);
            }
            // Usar informaci√≥n b√°sica
            this.estado.informacionCiclo = {
                id: cicloId,
                nombre: `Ciclo ${cicloId}`,
                estado: 'activo'
            };
        }
    },

    /**
     * Actualizar selectores de ciclo en todas las p√°ginas
     */
    actualizarSelectoresCiclo(cicloId) {
        const selectores = [
            '#selectCiclo',
            '#selectorCiclo select',
            'select[name="ciclo"]',
            '#cicloAcademico'
        ];
        
        selectores.forEach(selector => {
            const elemento = document.querySelector(selector);
            if (elemento) {
                // Buscar la opci√≥n correspondiente
                const opcion = Array.from(elemento.options).find(opt => opt.value === cicloId);
                if (opcion) {
                    elemento.value = cicloId;
                    console.log(`‚úÖ Selector ${selector} actualizado a ciclo ${cicloId}`);
                }
            }
        });
    },

    /**
     * Configurar eventos globales
     */
    configurarEventosGlobales() {
        // Escuchar cambios en selectores de ciclo
        document.addEventListener('change', (event) => {
            const selectoresCiclo = ['#selectCiclo', '#selectorCiclo select', 'select[name="ciclo"]', '#cicloAcademico'];
            
            if (selectoresCiclo.some(selector => event.target.matches(selector))) {
                const nuevoCiclo = event.target.value;
                if (nuevoCiclo && nuevoCiclo !== this.estado.cicloSeleccionado) {
                    console.log(`üîÑ Cambio de ciclo detectado en selector: ${nuevoCiclo}`);
                    this.establecerCiclo(nuevoCiclo);
                }
            }
        });
        
        // Escuchar eventos personalizados de cambio de ciclo
        document.addEventListener('cicloSeleccionado', (event) => {
            const { cicloId } = event.detail;
            if (cicloId && cicloId !== this.estado.cicloSeleccionado) {
                console.log(`üîÑ Evento de cambio de ciclo recibido: ${cicloId}`);
                this.establecerCiclo(cicloId);
            }
        });
        
        // Escuchar eventos de sincronizaci√≥n
        document.addEventListener('sincronizar-ciclo', (event) => {
            const { cicloId } = event.detail;
            if (cicloId) {
                this.establecerCiclo(cicloId);
            }
        });
    },

    /**
     * Configurar actualizaci√≥n autom√°tica
     */
    configurarActualizacionAutomatica() {
        // Reducir frecuencia y agregar detecci√≥n de servidor offline
        this.intervaloId = setInterval(() => {
            this.verificarActualizaciones();
        }, 60000); // Cambiar de 30s a 60s
    },

    /**
     * Verificar actualizaciones del servidor
     */
    async verificarActualizaciones() {
        // Solo verificar si el servidor est√° disponible
        if (this.estado.servidorOffline) {
            console.log('‚ö†Ô∏è Servidor offline, omitiendo verificaci√≥n autom√°tica');
            return;
        }

        try {
            const cicloActivo = await this.obtenerCicloActivo();
            if (cicloActivo && cicloActivo.id.toString() !== this.estado.cicloSeleccionado) {
                console.log(`üîÑ Ciclo activo cambiado en servidor: ${cicloActivo.id}`);
                await this.establecerCiclo(cicloActivo.id.toString());
            }
            // Marcar servidor como online si la petici√≥n fue exitosa
            this.estado.servidorOffline = false;
        } catch (error) {
            // Marcar servidor como offline tras error
            this.estado.servidorOffline = true;
            // Solo mostrar mensaje si no es un error de conexi√≥n com√∫n
            if (!error.message?.includes('Failed to fetch')) {
                console.log('üì° Servidor no disponible, activando modo offline');
            }
        }
    },

    /**
     * Suscribirse a cambios de ciclo
     */
    suscribirse(callback) {
        this.estado.suscriptores.add(callback);
        console.log('‚úÖ Suscriptor agregado al sistema de sincronizaci√≥n');
        
        // Devolver funci√≥n para desuscribirse
        return () => {
            this.estado.suscriptores.delete(callback);
            console.log('‚úÖ Suscriptor removido del sistema de sincronizaci√≥n');
        };
    },

    /**
     * Notificar a todos los suscriptores
     */
    notificarSuscriptores() {
        const datos = {
            cicloId: this.estado.cicloSeleccionado,
            informacion: this.estado.informacionCiclo,
            timestamp: this.estado.ultimaActualizacion
        };
        
        this.estado.suscriptores.forEach(callback => {
            try {
                callback(datos);
            } catch (error) {
                console.error('‚ùå Error en suscriptor:', error);
            }
        });
    },

    /**
     * Emitir evento personalizado
     */
    emitirEvento(tipo, datos) {
        const evento = new CustomEvent(tipo, {
            detail: datos,
            bubbles: true
        });
        document.dispatchEvent(evento);
    },

    /**
     * Obtener ciclo actual
     */
    obtenerCicloActual() {
        return {
            id: this.estado.cicloSeleccionado,
            informacion: this.estado.informacionCiclo,
            ultimaActualizacion: this.estado.ultimaActualizacion
        };
    },

    /**
     * Obtener estad√≠sticas del ciclo actual
     */
    async obtenerEstadisticasCiclo() {
        if (!this.estado.cicloSeleccionado) {
            return null;
        }
        
        try {
            const response = await window.apiRequest(
                `${this.config.endpoints.estadisticas}?ciclo=${this.estado.cicloSeleccionado}`, 
                'GET'
            );
            return response.data;
        } catch (error) {
            console.warn('‚ö†Ô∏è Error obteniendo estad√≠sticas del ciclo:', error.message);
            return null;
        }
    },

    /**
     * Forzar sincronizaci√≥n manual
     */
    async sincronizarManual() {
        console.log('üîÑ Sincronizaci√≥n manual iniciada...');
        await this.cargarCicloInicial();
        console.log('‚úÖ Sincronizaci√≥n manual completada');
    },

    /**
     * Detectar si el servidor est√° disponible
     */
    async detectarServidor() {
        try {
            const response = await window.apiRequest(this.config.endpoints.cicloActivo, 'GET');
            this.estado.servidorOffline = false;
            console.log('‚úÖ Servidor detectado como disponible');
            return true;
        } catch (error) {
            this.estado.servidorOffline = true;
            console.log('üì° Servidor no disponible');
            return false;
        }
    },

    /**
     * Pausar actualizaciones autom√°ticas
     */
    pausarActualizaciones() {
        if (this.intervaloId) {
            clearInterval(this.intervaloId);
            this.intervaloId = null;
            console.log('‚è∏Ô∏è Actualizaciones autom√°ticas pausadas');
        }
    },

    /**
     * Reanudar actualizaciones autom√°ticas
     */
    reanudarActualizaciones() {
        if (!this.intervaloId) {
            this.configurarActualizacionAutomatica();
            console.log('‚ñ∂Ô∏è Actualizaciones autom√°ticas reanudadas');
        }
    },

    /**
     * Obtener estado del servidor
     */
    obtenerEstadoServidor() {
        return {
            offline: this.estado.servidorOffline,
            ultimaVerificacion: this.estado.ultimaActualizacion
        };
    }
};

// Inicializar autom√°ticamente cuando el DOM est√© listo
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        SincronizacionCiclos.inicializar();
    });
} else {
    SincronizacionCiclos.inicializar();
}

// Exportar al scope global
window.SincronizacionCiclos = SincronizacionCiclos;

console.log('‚úÖ Sistema de sincronizaci√≥n de ciclos cargado');